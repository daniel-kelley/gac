#
#  panel.rb
#
#  Copyright (c) 2021 by Daniel Kelley
#

require 'yaml'

class GAC::Panel

  #
  # Init GAC
  #
  def initialize
    @block = []
    @output = {} # key: output_type value: array of blocks
    @output_names = [] # output names in block order
  end

  #
  # Generate faust code
  #
  def generate(desc)
    panel = File.open(desc) { |yf| YAML::load(yf) }
    analyze_panel(panel)
    collect_io_types
    register_block_io
    generate_panel(desc,panel)
  end

  def info
    GAC::Lib.info
  end

  private

  #
  # Analyze panel configuration
  #
  def analyze_panel(panel)
    #RM outputs = panel['outputs']
    #RM inputs = panel['inputs']
    #RM @outputs = outputs.nil? ? 0 : Integer(outputs)
    #RM @inputs = inputs.nil? ? 0 : Integer(inputs)
    #RM raise "no IO?" if @inputs == 0 && @outputs == 0
    blocks = panel['blocks']
    raise "missing blocks" if blocks.nil?
    blocks.each { |block| analyze_block(block) }
    #RM raise "needs support" if @inputs != 0

  end

  #
  # Analyze blocks and track
  #
  def analyze_block(block_type)
    block = GAC::Block.new(block_type)
    raise 'oops' if block.nil?
    @block << block
  end

  #
  # Gather all of the IO types used by the blocks
  #
  def collect_io_types
    @block.each do |block|
      @output_names << block.output_name
      next if block.output_type.nil?
      if @output[block.output_type].nil?
        @output[block.output_type] = []
      end
      @output[block.output_type] << block
    end
    #RM @outputs.times do |n|
    #RM   @output_names << "output#{n+1}_out"
    #RM end
  end

  #
  # Register the collected outputs with each of the blocks
  #
  def register_block_io
    @block.each { |block| block.register_output(@output) }
  end

  #
  # Return the panel header
  #
  def panel_header(desc)
    s = <<EOS
// GAC Panel Generated by #{$0} from #{desc}
gac = library("gac.lib");
// Control constants and converters
CONTROL_MIN = 0.0;
CONTROL_MAX = 1.0;
CONTROL_STEP = 0.01;
CONTROL_DEFAULT = CONTROL_MIN;
control2control(n) = n;

FREQ_MIN = 0.0;
FREQ_MAX = 20000.0;
FREQ_STEP = 0.01;
FREQ_DEFAULT = FREQ_MIN;
freq2control(n) = n/FREQ_MAX;
control2freq(n) = n*FREQ_MAX;

PERIOD_MIN = 0.0;
PERIOD_MAX = 1000.0;
PERIOD_STEP = 0.01;
PERIOD_DEFAULT = PERIOD_MIN;
period2control(n) = n/PERIOD_MAX;
control2period(n) = n*PERIOD_MAX;

Q_MIN = 0.0;
Q_MAX = 100.0;
Q_STEP = 0.01;
Q_DEFAULT = 1;
Q2control(n) = n/Q_MAX;
control2Q(n) = n*Q_MAX;

COUNT_MIN = 0;
COUNT_MAX = gac.N - 1;
COUNT_STEP = 1;
COUNT_DEFAULT = COUNT_MIN;
count2control(n) = n/COUNT_MAX;
control2count(n) = n*COUNT_MAX;

EOS
  s
  end

  #
  # Create a panel comment block with embedded YAML data
  #
  def comment_yamlize(data)
    s = []
    data.to_yaml.each_line { |line| s << "//#{line.chomp}" }
    s << "//...\n"
  end

  def panel_input(panel)
    comment_yamlize(panel)
  end

  #
  # REMOVE
  #
  def panel_output
    h = {}
    @output.each do |k,v|
      if h[k].nil?
        h[k] = []
      end
      v.each do |block|
        h[k] << block.output_name
      end
    end
    s = comment_yamlize(h)
    s << "// Output"
    s << GAC::Block.output(h['signal'])
  end

  def panel_blocks
    s = []
    @block.each { |block| s << block.fn_body }
    s
  end

  def panel_process
    s = []
    t = []
    s << "// Process"

    # panel function
    s << "panel("
    s << @output_names.join(",\n")
    s << ") = tgroup(\"top\","
    @block.each_with_index do |block,n|
      t << "vgroup(\"[#{n}]#{block.name}\",#{block.fn_call})"
    end
    s << t.join(",\n")
    s << ");"

    # copy function
    s << "copy("
    s << @output_names.join(",\n")
    s << ") = ("
    s << @output_names.join(",\n")
    s << ");"

    # output function
    s << "output("
    s << @output_names.join(",\n")
    s << ") = ("
    #RM @outputs.times { |n| s << "output#{n+1}_out" }
    s << @output_names.reject {|n| n !~ /^output/ }.join(",\n")
    s << ");"
    s << "process = (panel ~ copy) : output;"
    s
  end

  #
  # Generate faust panel code from panel description
  #
  def generate_panel(desc,panel)
    s = []
    s << panel_header(desc)
    s << panel_input(panel)
    s << panel_blocks
    # s << panel_output
    s << panel_process
    s.flatten.join("\n")
  end

end
